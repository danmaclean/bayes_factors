[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bayesian Inference with Bayes Factors",
    "section": "",
    "text": "Motivation",
    "crumbs": [
      "Motivation"
    ]
  },
  {
    "objectID": "index.html#mr.-micawbers-rule-of-scientific-success",
    "href": "index.html#mr.-micawbers-rule-of-scientific-success",
    "title": "Bayesian Inference with Bayes Factors",
    "section": "Mr. Micawber’s rule of scientific success",
    "text": "Mr. Micawber’s rule of scientific success\nWe really do need to move away from \\(p\\)-values as a gold-standard of truth in experimental science. The ruinous role of the \\(p\\)-value in modern science can not be overstated. This one value is responsible for happiness and despair in equal measure. They say money is the root of all unhappiness and Dicken’s Mr. Micawber had this to say about the role of money in life:\n\n‘Annual income 20 pounds, annual expenditure 19 [pounds] 19 shillings and six pence, result happiness. Annual income 20 pounds, annual expenditure 20 pounds ought and six, result misery.’\n\nin science a corollary exists:\n\n‘\\(p\\) below 0.05, result success, papers, grants, and tenure. \\(p\\) above 0.05 result failure, misery, ignominy, and rejection.’\n\nThe truth is that \\(p &lt; 0.05\\) is an entirely arbitrary cut-off and is not in itself a helpful or meaningful value. Various scientific communities, led by publishing requirements, have accepted \\(p &lt; 0.05\\) as a gold standard of truth against sense and often against rigorousness. With Bayesian tests we will be able to completely do away with \\(p\\)-values and confidence intervals and in their place use a more evidence based approach to making inferences.",
    "crumbs": [
      "Motivation"
    ]
  },
  {
    "objectID": "index.html#learning-to-select-hypotheses-using-bayesian-approaches",
    "href": "index.html#learning-to-select-hypotheses-using-bayesian-approaches",
    "title": "Bayesian Inference with Bayes Factors",
    "section": "Learning to select hypotheses using Bayesian approaches",
    "text": "Learning to select hypotheses using Bayesian approaches\nThe sort of statistics that most experimental science students are taught are called ‘Frequentist Statistics’. They include the \\(t\\)-tests, ANOVA and \\(\\chi^2\\)-tests and the linear models that we have studied already.\nThe inferential approach (how we make decisions about data) in the Frequentist paradigm is often criticised for being weak and is often abused. Although the abuse is as much a consequence of convention in the scientific literature and in scientific publishing, the misinterpretation of \\(p\\)-values by generations of scientists as it is the philosophical weakness of the methods themselves, the weaknesses persist and over time other paradigms have emerged.\nWe have seen an alternative in Estimation Statistics, in this course we will look at another - Bayesian Inference. We will use Bayes Factors to compare levels of evidence for one hypothesis over another, rather than just accepting or rejecting a simplistic null hypothesis.\nThe advantage of this will be that we can much more directly select between specific hypotheses that might describe our data. This will give us a much clearer idea about a question that we instinctively want to answer when we do statistics - ‘Which hypothesis is most likely true?’, we will see that we can formulate this in lots of ways, but in general the hypotheses we want to compare will be something along the lines of some measured quantity being different in different samples. With Frequentist Inference we can only ask the roundabout question, ‘How often does the difference we observe occur by chance?’ and if it isn’t likely, say so. With Bayes Factors we will be able to compare directly competing hypotheses and reject the least likely absolutely.",
    "crumbs": [
      "Motivation"
    ]
  },
  {
    "objectID": "bayes_factor_intro.html",
    "href": "bayes_factor_intro.html",
    "title": "1  Bayesian Inference",
    "section": "",
    "text": "1.1 About this chapter",
    "crumbs": [
      "Background",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Bayesian Inference</span>"
    ]
  },
  {
    "objectID": "bayes_factor_intro.html#about-this-chapter",
    "href": "bayes_factor_intro.html#about-this-chapter",
    "title": "1  Bayesian Inference",
    "section": "",
    "text": "Questions\n\nWhat is probability?\nWhat does Bayes Theorem do?\nHow can we compare hypotheses about data?\n\nObjectives\n\nUnderstand the differences between Frequentist and Bayesian probability\nGet an appreciation of Bayes Theorem\nUnderstand what a Bayes Factor represents\n\nKeypoints\n\nProbability can be based on frequency of events or the level of knowledge we have about a thing\nBayes Theorem gives a likelihood based on evidences that can change\nBayes Factors are useful in comparing hypothesis about the same evidence",
    "crumbs": [
      "Background",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Bayesian Inference</span>"
    ]
  },
  {
    "objectID": "bayes_factor_intro.html#frequentist-and-bayesian-interpretations-of-probability",
    "href": "bayes_factor_intro.html#frequentist-and-bayesian-interpretations-of-probability",
    "title": "1  Bayesian Inference",
    "section": "1.2 Frequentist and Bayesian Interpretations of Probability",
    "text": "1.2 Frequentist and Bayesian Interpretations of Probability\nIt may seem like a strange question to ask, but what, exactly, is probability? Whatever it is it certainly isn’t a solid thing that we could carry in a bucket. Probability is a strange and often ill-defined concept that can get very confusing when one starts to think deeply about it. When asked what probability is people will generally start to talk about vague concepts like chance or likelihood or randomness or fate, even. Most people will give examples of coins being thrown or dice being rolled. This ephemerality is no good when we want to use probability so when it comes to working with probability statisticians needed to develop very precise definitions. It turns out that different ways of thinking about likelihoods can result in very different definitions of probability.\nThe two definitions that we will consider are those called the Frequentist and the Bayesian definitions\n\n1.2.1 Frequentist Probability\nThe Frequentist definition of probability is based on the frequency of occurrence of events. This is a definition that is most similar to the coin toss or dice throw intuition about probability. A probability can be stated thus\n\\(P(Event) = \\frac{\\text{number of ways event can happen}}{\\text{number of all possible outcomes}}\\)\nSo in a coin toss, we might get the following probability of getting ‘heads’\n\\(P(heads) = \\frac{\\text{number of heads on the coin}}{\\text{number of sides to the coin}}\\)\nwhich of course, computes as\n\\(P(heads) = \\frac{1}{2}\\)\nThinking of probabilities in this way is similar to a gambler who plays games of chance like roulette or craps, where the odds of winning are entirely based on the outcome of simple random process.\nThis is so simple and intuitive that we might be tempted to think it’s the natural way to think about probabilities, but there are other definitions.\n\n\n1.2.2 Bayesian Probablity\nThe Bayesian definition of probability is different, it takes probability to be a reasonable expectation of an event, depending on the knowledge that the observer has. You might understand these probabilities similarly to a gambler that bets on horse races and changes their assessment of a horse’s winning ability based on the conditions of the ground and the weight of the jockey. These are trickier to understand than the Frequentist definition but an example can be helpful.\nConsider that you and a friend are playing cards and that your friend claims to be able to guess the identity of a card that you draw and replace. A frequentist probability would say that the probability of this was \\(P(correct) = \\frac{1}{52}\\). However, you know that your friend is an amateur magician, so you expect that the probability of a correct guess would be much higher than that. That is to say that you have a different reasonable expectation because you have incorporated prior knowledge into your working. Bayesian Probability is based on this prior knowledge and updating of belief based on that knowledge to come up with a posterior likelihood of an event.\nIn rough terms the answer - a ‘posterior probability’ is arrived at by combining a ‘prior probability’ and ‘evidence’. In the card guess example the ‘prior probability’ was the raw chance based probability that anyone would guess the card \\(\\frac{1}{52}\\), the ‘evidence’ was the fact that your friend was an amateur magician and the ‘posterior probability’ was the updated ‘prior probability’ that the chance of guessing was higher than \\(\\frac{1}{52}\\).\nOne problem we might spot is how exactly do we update our probability to actually get a measure of the posterior? A formula known as Bayes Theorem lets us do the calculation, but it can be very hard to get the actual numbers we need for evidence and this can be a barrier to using Bayes in the real world. However, let’s look work one calculation through with some assumed numbers to get a feel.",
    "crumbs": [
      "Background",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Bayesian Inference</span>"
    ]
  },
  {
    "objectID": "bayes_factor_intro.html#bayes-theorem-by-rough-example",
    "href": "bayes_factor_intro.html#bayes-theorem-by-rough-example",
    "title": "1  Bayesian Inference",
    "section": "1.3 Bayes Theorem by Rough Example",
    "text": "1.3 Bayes Theorem by Rough Example\nThe mathematical basis of calculating a posterior belief or likelihood is done with a formula called Bayes Theorem. Which, using our card example defines the posterior as\n\\(P(correct | magician)\\)\nwhich reads as the probability of a guess being correct once you know you are working with a magician.\nIt defines the prior as\n\\(P(correct)\\)\nwhich reads as the probability of being correct in a random guess (which we know to be \\(\\frac{1}{52}\\))\nAnd it defines the evidence as\n\\(P(magician|correct)\\)\nwhich reads as the probability of the person being a magician given a guess was correct. This is the number which can be hardest to work out in general though in this case we might say it is quite high, say 0.9.\nBayes Theorem then works out the posterior probability given these numbers. There is a very famous formula for this, that I won’t include here for simplicity sake, but it is very interesting. We can take a short cut and use R to work out the posterior from the prior and the evidence as follows\n\nlibrary(LaplacesDemon)\nprior &lt;- c(51/52,1/52) \nevidence &lt;- c(0.9, 0.1)\n\nBayesTheorem(prior, evidence)\n\n[1] 0.997826087 0.002173913\nattr(,\"class\")\n[1] \"bayestheorem\"\n\n\nas it is the first reported number we want, we can see that we get a 99% posterior probability that the guess will be correct if we know that the 90% of correct guesser’s are magicians.\nThe key thing to take away here is that the Bayesian Probability allows us to modify our view based on changes in the evidence. This is a key attribute as we can use it to compare the resulting posteriors from different evidences. In other words it allows us to compare different hypotheses based on different evidence to see which is the more likely.",
    "crumbs": [
      "Background",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Bayesian Inference</span>"
    ]
  },
  {
    "objectID": "bayes_factor_intro.html#hypotheses-in-frequentist-and-bayesian-statistics",
    "href": "bayes_factor_intro.html#hypotheses-in-frequentist-and-bayesian-statistics",
    "title": "1  Bayesian Inference",
    "section": "1.4 Hypotheses in Frequentist and Bayesian Statistics",
    "text": "1.4 Hypotheses in Frequentist and Bayesian Statistics\nNow that we know Bayes Statistics allow for updating our beliefs in the light of different evidence we can look at how we can formulate hypotheses to take advantage of this and do something very different with Bayes than we do with Frequentist ideas.\nLet’ recap the logic of hypothesis tests in Frequentist statistics.\n\n1.4.1 Frequentist Hypotheses\nYou may recall that the first step of doing a hypothesis test like a \\(t\\)-test is to set up our hypotheses. The first \\(H_0\\) is the null hypothesis which represents the situation where there is no difference and \\(H_1\\) is the alternative. Next we select a Null model that represents the Null hypothesis, this step is usually implicit at the operator level and comes as part of the linear model or \\(t\\)-test that we choose to use, and usually is based on the Normal Distribution. Our hypothesis represent the situation as follows\n\n\\(H_0 : \\bar{x}_1 - \\bar{x}_2 = 0\\) IE, the sample means are equal.\n\\(H_1 : \\bar{x}_2 - \\bar{x}_2 \\neq 0\\) IE, the sample means are not equal.\n\nWe test \\(H_0\\) (the Null Hypothesis and Model) to see how likely the observed result is under that and if it is unlikely at some level (\\(p\\)) then we reject \\(H_0\\) and accept \\(H_1\\).\nWe criticised this for being weak inference in the Linear Model course. Let’s do that again. In this framework haven’t we accepted \\(H_1\\) without analysing it? Here it means that we have had to set up hypotheses that are binary and not compare them directly. We have a take or leave approach to hypotheses.\nWe haven’t, for example been able to ask whether \\(\\bar{x}_1 &gt; \\bar{x}_2\\) because that wouldn’t be askable under our single test, binary paradigm. That’s a limitation. As scientists we should be able to collect data and compare models or hypotheses about that data directly.\n\n\n1.4.2 Bayesian Hypotheses\nIn the Bayesian Framework we can formulate hypotheses as we wish and compare them directly, using Bayesian probabilities to examine models with different evidences and priors. So if the evidence shows that \\(H_1\\) isn’t any more believable than \\(H_0\\) we wouldn’t falsely fall into the trap of believing \\(H_1\\) was somehow more correct.\nBayesian Hypotheses can be a bit more like this\n\n\\(H_0 : \\bar{x}_1 &lt; \\bar{x}_2\\) IE sample 1 has a lower mean than sample 2\n\\(H_1 : \\bar{x}_1 &gt; \\bar{x}_2\\) IE sample 1 has a higher mean than sample 2.\n\nwhich is often much more intellectually satisfying and can lead to clearer answers than the more binary Frequentist hypotheses.\nA significant limitation of the approach is the need to select and quantify the prior and the evidence, which can be crucial and lead to very different outcomes if different values are chosen.\nSelection of the prior knowledge itself is very difficult and no suitable data may exist. Getting the right data is subjective in many cases and there is no one right way. Domain knowledge is important and often crucial but this can easily lead to bias. An unwitting, uncareful (or say it quietly - unscrupulous) operator could select a prior that would bias the result in favour of a preferred hypothesis. This is a form of confirmation bias or interpretation of the data in a way that confirms your prior beliefs.\nFor these reasons Frequentist approaches are often the most pragmatic and a priori transparent method, though if the priors and evidence can be collected in a non-biased way Bayesian approaches offer us excellent alternatives.",
    "crumbs": [
      "Background",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Bayesian Inference</span>"
    ]
  },
  {
    "objectID": "bayes_factor_intro.html#bayes-factors",
    "href": "bayes_factor_intro.html#bayes-factors",
    "title": "1  Bayesian Inference",
    "section": "1.5 Bayes Factors",
    "text": "1.5 Bayes Factors\nWe can use Bayesian Inference through a tool known as Bayes Factors. Bayes Factors are a method of directly comparing the posteriors of different models with different evidences and priors.\nBayes Factors make a ratio of the result of one model or hypothesis over another, resulting in a single quantity that we can examine. Consider that our hypotheses above have been put through the process and a result gained thus\n\n\\(H_0 : \\bar{x}_1 &lt; \\bar{x}_2 \\leadsto Posterior = 0.2\\)\n\\(H_1 : \\bar{x}_1 &gt; \\bar{x}_2 \\leadsto Posterior = 0.6\\)\n\nWe can clearly see that \\(H_1\\) has 3 times more support than \\(H_0\\) and we would want to accept that as a better explanation of our data.\nBayes Factors are just that, the ratio of the relative goodness of the hypotheses. From this we can make statements about the support for hypotheses. Wagenmakers et al. (2011) created a table of thresholds indicating interpretations for different Bayes Factors on two hypotheses.\n\n\n\n\n\nBayes.Factor\nInterpretation\n\n\n\n\n&gt;100\nExtreme evidence for \\(H_0\\) compared to \\(H_1\\)\n\n\n30..100\nVery Strong evidence for \\(H_0\\) compared to \\(H_1\\)\n\n\n10..30\nStrong evidence for \\(H_0\\) compared to \\(H_1\\)\n\n\n3..10\nSubstantial evidence for \\(H_0\\) compared to \\(H_1\\)\n\n\n1..3\nAnecdotal evidence for \\(H_0\\) compared to \\(H_1\\)\n\n\n1\nNo evidence\n\n\n1..1/3\nAnecdotal evidence for \\(H_1\\) compared to \\(H_0\\)\n\n\n1/3..1/10\nSubstantial evidence for \\(H_1\\) compared to \\(H_0\\)\n\n\n1/10..1/30\nStrong evidence for \\(H_1\\) compared to \\(H_0\\)\n\n\n1/30..1/100\nVery Strong evidence for \\(H_1\\) compared to \\(H_0\\)\n\n\n&lt;1/100\nExtreme evidence for \\(H_1\\) compared to \\(H_0\\)\n\n\n\n\n\nThese are extremely useful especially when used with other measures and interpretations like estimation statistics to allow us to make statistical claims.\nIn the next chapters we will look at how to use Bayes Factors in place of common frequentist hypothesis tests.\n\n\n\n\n\n\nNote\n\n\n\nThe Wagenmakers et al. (2011) article is fun if you can get hold of it. It’s a commentary on an earlier article in which the researchers conclude that people have the ability to see into the future! Which they arrive at by misapplying statistics the same way that researchers across all fields do. Wagenmakers et al reperform the analysis with Bayes Factors and show that the original conclusions are unsound.",
    "crumbs": [
      "Background",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Bayesian Inference</span>"
    ]
  },
  {
    "objectID": "bayes_factor_intro.html#references",
    "href": "bayes_factor_intro.html#references",
    "title": "1  Bayesian Inference",
    "section": "1.6 References",
    "text": "1.6 References\n\n\n\n\nWagenmakers, E. J., T. Wetzels, D. Borsboom, and H. L. J van der Maas. 2011. “Why Psychologists Must Change the Way They Analyze Their Data: The Case of Psi: Comment on Bem (2011).” Journal of Personality and Social Psychology 100: 426–32. https://doi.org/https://doi.org/10.1037/a0022790.",
    "crumbs": [
      "Background",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Bayesian Inference</span>"
    ]
  },
  {
    "objectID": "bayes_t.html",
    "href": "bayes_t.html",
    "title": "2  Bayes Factor \\(t\\)-tests",
    "section": "",
    "text": "2.1 About this chapter\nIn this section we’ll look at how we can do a \\(t\\)-test-like two sample comparison with Bayes Factors. The process is surprisingly straight forward but does need us to pay attention to the weaknesses of the Bayes method - specifically choosing the prior probability distribution. To actually do the tests we’ll use the ttestBF() in the BayesFactor package.",
    "crumbs": [
      "Tests with Bayes Factors",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Bayes Factor $t$-tests</span>"
    ]
  },
  {
    "objectID": "bayes_t.html#about-this-chapter",
    "href": "bayes_t.html#about-this-chapter",
    "title": "2  Bayes Factor \\(t\\)-tests",
    "section": "",
    "text": "Questions\n\nHow can I do compare two continuous samples with Bayes Factors?\nHow can I specify a directional hypothesis?\nHow much difference does the prior make?\n\nObjectives\n\nUnderstand how a Bayes Factor \\(t\\)-test can be done in R\nConsider how \\(p\\) and the Bayes Factor are not contradictory\nUnderstand that hypothesis and prior selection is important\n\nKeypoints\n\nThe BayesFactor package provides functions for Bayes Factor analysis\nBayes Factors and \\(p\\)-values ask very different questions\nOne-tailed tests are possible and may be better options",
    "crumbs": [
      "Tests with Bayes Factors",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Bayes Factor $t$-tests</span>"
    ]
  },
  {
    "objectID": "bayes_t.html#a-frequentist-t-test",
    "href": "bayes_t.html#a-frequentist-t-test",
    "title": "2  Bayes Factor \\(t\\)-tests",
    "section": "2.2 A Frequentist \\(t\\)-test",
    "text": "2.2 A Frequentist \\(t\\)-test\nTo begin we’ll first do a normal \\(t\\)-test with a sample data set as a basis for later comparison\n\n2.2.1 The Plant Growth data set\nYou may recall the Plant Growth data set we used in the Linear Models course, here’s a reminder\n\n\n     weight       group   \n Min.   :3.590   ctrl:10  \n 1st Qu.:4.550   trt1:10  \n Median :5.155   trt2:10  \n Mean   :5.073            \n 3rd Qu.:5.530            \n Max.   :6.310            \n\n\n\n\n\n\n\n\n\nWe will use this as an example data set, specifically we’ll use ctrl and trt2 data, which we need to extract. Note the mean values for trt2 look larger than ctrl.\n\nlibrary(dplyr)\npg_small &lt;- PlantGrowth %&gt;% \n  filter(group %in% c(\"trt2\", \"ctrl\")) %&gt;% \n  droplevels()\n\nlet’s calculate too the sample difference mean and the standardised effect size, as it will be important to know these values later\n\nlibrary(tidyr)\npg_small %&gt;% \n  group_by(group) %&gt;% \n  summarise(mean_weight = mean(weight)) %&gt;% \n  pivot_wider( names_from = group, values_from = mean_weight) %&gt;% \n  summarise(mean_sample_diff = `trt2` - `ctrl`)\n\n# A tibble: 1 × 1\n  mean_sample_diff\n             &lt;dbl&gt;\n1            0.494\n\n\nSo the mean of trt2 is bigger than ctrl by 0.49 g.\n\nlibrary(effectsize)\ncohens_d(weight ~ group, data=pg_small)\n\nCohen's d |         95% CI\n--------------------------\n-0.95     | [-1.87, -0.01]\n\n- Estimated using pooled SD.\n\n\nAnd correspondingly the standardised effect size is large. The effect size is negative because the calculation has been done in the order that the groups appear in the data. ctrl comes first so the calculation was ctrl - trt2 which is a negative value. For now, this won’t matter. We will need to pay attention to it later.\n\n\n2.2.2 Two Sample \\(t\\)-test\nLet’s now do the \\(t\\)-tests. The hypotheses for a test comparing the treatment groups are\n\n\\(H_0 : \\bar{trt2} - \\bar{ctrl} = 0\\) IE the mean sample difference is 0\n\\(H_1 : \\bar{trt2} - \\bar{ctrl} \\neq 0\\) IE the mean sample difference is not 0\n\nUsing these data to do a \\(t\\)-test is easy, we’ll specify a cut-off of 0.05 for rejection of \\(H_0\\).\n\nmodel &lt;- lm(weight ~ group, data = pg_small)\nsummary(model)\n\n\nCall:\nlm(formula = weight ~ group, data = pg_small)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-0.862 -0.410 -0.006  0.280  1.078 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   5.0320     0.1637  30.742   &lt;2e-16 ***\ngrouptrt2     0.4940     0.2315   2.134   0.0469 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.5176 on 18 degrees of freedom\nMultiple R-squared:  0.2019,    Adjusted R-squared:  0.1576 \nF-statistic: 4.554 on 1 and 18 DF,  p-value: 0.04685\n\n\nWe get a \\(p\\)-value of 0.046 which is less than our cut-off of 0.05 so we reject \\(H_0\\) as unlikely and accept \\(H_1\\) without explicitly testing it. Our conclusion scientifically is that trt2 has greater weight than ctrl.",
    "crumbs": [
      "Tests with Bayes Factors",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Bayes Factor $t$-tests</span>"
    ]
  },
  {
    "objectID": "bayes_t.html#a-bayesian-t-test",
    "href": "bayes_t.html#a-bayesian-t-test",
    "title": "2  Bayes Factor \\(t\\)-tests",
    "section": "2.3 A Bayesian \\(t\\)-test",
    "text": "2.3 A Bayesian \\(t\\)-test\nNow let’s set up a BayesFactor \\(t\\)-test. First we must set our hypotheses. The null hypothesis is similar to that in the frequentist \\(t\\)-test, the idea is that there is no effect which we formulated above as\n\n\\(H_0 : \\bar{trt2} - \\bar{ctrl} = 0\\) IE the mean sample difference is 0\n\nAnother way to say this is that the effect size \\(d\\) is 0 so\n\n\\(H_0 : d = 0\\)\n\nBecause we need something to compare against we now need to form the alternative hypothesis. By default the ttestBF() function tests the alternative hypothesis that the effect size is not 0\n\n\\(H_1 : d \\neq 0\\)\n\nand returns the Bayes Factor we need. Performing the test is straightforward\n\nlibrary(BayesFactor)\nttestBF(formula =  weight ~ group, data = pg_small)\n\nBayes factor analysis\n--------------\n[1] Alt., r=0.707 : 1.774688 ±0%\n\nAgainst denominator:\n  Null, mu1-mu2 = 0 \n---\nBayes factor type: BFindepSample, JZS\n\n\nWe get a clear answer, the output on the line marked[1] is a Bayes Factor and states that the data are 1.77 times more likely if \\(H_1\\) were true than if \\(H_0\\) were true. In other words the odds of the data favouring the \\(H_1\\) to \\(H_0\\) are 1.77:1. Which is the answer we wanted to get, we have explicitly tested \\(H_0\\) and \\(H_1\\) and found that \\(H_1\\) is more likely to fit the data.",
    "crumbs": [
      "Tests with Bayes Factors",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Bayes Factor $t$-tests</span>"
    ]
  },
  {
    "objectID": "bayes_t.html#comparing-p-and-the-bayes-factor-for-the-plantgrowth-data",
    "href": "bayes_t.html#comparing-p-and-the-bayes-factor-for-the-plantgrowth-data",
    "title": "2  Bayes Factor \\(t\\)-tests",
    "section": "2.4 Comparing \\(p\\) and the Bayes Factor for the PlantGrowth data",
    "text": "2.4 Comparing \\(p\\) and the Bayes Factor for the PlantGrowth data\nComparing to our table of interpretation of Bayes Factors, we see that this corresponds only to ‘Anecdotal Evidence’ in favour of \\(H_1\\), which sounds weak and like really there isn’t much evidence for the idea that the two samples are different. Do we find this surprising given that the \\(p\\)-value from the \\(t\\)-test was significant? Does this mean that the two methods disagree? Strictly speaking, no, we shouldn’t be surprised and no they don’t disagree.\nIt’s a bit of an apples and oranges situation. The two values are answers to very different questions.\nAs we’ve said before the frequentist \\(p\\)-value only measures the proportion of times a difference of the measured size would occur under some presumed background model. It does not measure the evidence that the hypothesis is true even though that is how many people try to interpret it. \\(p\\) only tells us how often we would be wrong if we reject \\(H_0\\). As a result, many philosophers have stated that \\(p\\) based significance is a fundamentally uninteresting measure - who cares how often a difference occurs in some ideal world - what is important is the relative fit of the competing hypotheses to the data and that this measure of the strength of evidence per hypothesis is more in line with the interests of researchers.\nTaken together our \\(p\\)-value states that the difference between the means of trt2 and ctrl we observed occurs by chance in a normal distribution less than 0.05% of the time and the Bayes Factor tells us that the odds that the data favour the idea that trt2 is not the same as ctrl are only 1.7 times greater than the idea that trt2 and ctrl are equal. We can see that the two methods do not contradict.\nHopefully this brings home the idea that Bayes Factor is different and arguably closer to what many scientists think they are doing when they do frequentist statistics.\nInterpreting these results correctly, then, logically means that a researcher is not likely to be very excited by the results and would not over value the significance of the observed difference.",
    "crumbs": [
      "Tests with Bayes Factors",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Bayes Factor $t$-tests</span>"
    ]
  },
  {
    "objectID": "bayes_t.html#better-hypotheses---one-tailed-tests",
    "href": "bayes_t.html#better-hypotheses---one-tailed-tests",
    "title": "2  Bayes Factor \\(t\\)-tests",
    "section": "2.5 Better Hypotheses - One-tailed tests",
    "text": "2.5 Better Hypotheses - One-tailed tests\nBut looking at the hypotheses we generated, could we ask a better, more informative one? With frequentist tests, no, but with Bayes Factors we can test different hypothesis. Instead of asking whether trt2 is the same as ctrl or not we could ask something more specific. We are likely interested in whether trt2 is greater than ctrl, or in other words that the effect size is greater than 0\n\n\\(H_1 : d &gt; 0\\)\n\nWe can specify this \\(H_1\\) by setting the nullInterval argument, this is just the range we expect the effect sizes to be in under the null hypothesis, so we can use 0 to Infinity to cover any increased effect size (and -Infinity to 0 for any decreased effect size.\n\n2.5.1 A data frame based gotcha\nHere is where we can run afoul of R’s idiosyncarcies - it is important to be careful here because the order of the data in the dataframe can have an effect that can confuse us. Recall that our effect size calculation for these data came out negative because ctrl came before trt2. Look at the dataframe pg_small.\n\nstr(pg_small)\n\n'data.frame':   20 obs. of  2 variables:\n $ weight: num  4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...\n $ group : Factor w/ 2 levels \"ctrl\",\"trt2\": 1 1 1 1 1 1 1 1 1 1 ...\n\n\nNote that the ctrl level in the group factor is first, we need to think of our \\(H_1\\) more carefully,\n\n\\(H_1 : d &gt; 0\\)\n\nreally is in this case\n\n\\(H_1 : \\bar{\\text{trt2}} - \\bar{\\text{ctrl}} &gt; 0\\)\n\nso we need to make sure that trt2 comes first in the group factor. We can use the $ notation to reorder the factor as we wish\n\npg_small$group &lt;- factor(pg_small$group, \n                         levels=c(\"trt2\", \"ctrl\") )\nstr(pg_small)\n\n'data.frame':   20 obs. of  2 variables:\n $ weight: num  4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...\n $ group : Factor w/ 2 levels \"trt2\",\"ctrl\": 2 2 2 2 2 2 2 2 2 2 ...",
    "crumbs": [
      "Tests with Bayes Factors",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Bayes Factor $t$-tests</span>"
    ]
  },
  {
    "objectID": "bayes_t.html#performing-the-one-tailed-test",
    "href": "bayes_t.html#performing-the-one-tailed-test",
    "title": "2  Bayes Factor \\(t\\)-tests",
    "section": "2.6 Performing the One-tailed test",
    "text": "2.6 Performing the One-tailed test\nWith that done we can move back on with the one-sided test, specifying the interval as expected.\n\nttestBF(formula =  weight ~ group, data = pg_small, nullInterval=c(0, Inf))\n\nBayes factor analysis\n--------------\n[1] Alt., r=0.707 0&lt;d&lt;Inf    : 3.387166  ±0%\n[2] Alt., r=0.707 !(0&lt;d&lt;Inf) : 0.1622109 ±0%\n\nAgainst denominator:\n  Null, mu1-mu2 = 0 \n---\nBayes factor type: BFindepSample, JZS\n\n\nPerforming the test was nice and easy and we get an answer. The first line of the output [1] states the odds that the data favour the alternative hypothesis over the null are 3.38:1. The Bayes Factor is increased over the earlier more vague hypothesis, suggesting there is actually substantial evidence for the idea that the effect size is greater than 0.",
    "crumbs": [
      "Tests with Bayes Factors",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Bayes Factor $t$-tests</span>"
    ]
  },
  {
    "objectID": "bayes_t.html#testing-the-effect-of-the-prior",
    "href": "bayes_t.html#testing-the-effect-of-the-prior",
    "title": "2  Bayes Factor \\(t\\)-tests",
    "section": "2.7 Testing the effect of the prior",
    "text": "2.7 Testing the effect of the prior\nWe discussed that one of the limitations of Bayesian Inference was the need to carefully and justifiably select a prior and that doing so was difficult. We’ll look at that a little bit now as we did make a decision on this albeit implicitly by allowing the defaults of the ttestBF() function.\nIn our ttestBF() function we actually need to provide a prior distribution for the maths to work, not just a single value. We don’t want to get into details of those maths as they are out of scope but we do need to know that the prior distribution needs to cover a range of effect sizes that might be plausible if the null hypothesis were false.\nThe BayesFactor package provides a Cauchy distribution as default. Since the selection of the prior implies that we know something about our dat, using the Cauchy implies that we think the population is normally distributed (which is the same distribution we assume under the standard frequentist statistical tests).\n\n2.7.1 The Cauchy Prior Distribution\nThe Cauchy is a distribution with a single parameter called scale that affects how wide its main humpy bit is. In BayesFactor there are three widths we can choose from depending on how big a difference we think we are seeing, that is how big the effect size. When plotted, these distributions look like this\n\n\n\n\n\n\n\n\n\nand the name corresponds to scale values as follows\n\n\n\n\n\nname\nscale\n\n\n\n\nmedium\n0.71\n\n\nwide\n1.00\n\n\nultrawide\n1.41\n\n\n\n\n\nIn each of the distributions 50% of the area under the curve falls within +/- the scale value.\nSince the scale on the \\(x\\)-axis in our plot is effect size, the choice of scale values says somerthing about what we are expecting our effect sizes to be like. The wider the scale value, the bigger we are expecting our effect sizes to be.\nOur effect size in the PlantGrowth data was 0.95 so well within the area covered by the medium scale Cauchy, much more of that curve falls within the -0.95 to +0.95 effect size range than the other two, so we might think that one would be a better fit. That’s why it’s the default, it’s a good fit for generally found effect sizes.\n\n\n2.7.2 The effect of changing the prior\nAs an exercise to help us understand the importance of the prior and explicitly NOT a guide to maximising the odds in favour of one model over another. Let’s look at how changing the scale via the rscale parameter in ttestBF() affects the odds of our one sided model.\n\nttestBF(formula =  weight ~ group, data = pg_small, nullInterval=c(0, Inf), rscale=\"medium\")\n\nBayes factor analysis\n--------------\n[1] Alt., r=0.707 0&lt;d&lt;Inf    : 3.387166  ±0%\n[2] Alt., r=0.707 !(0&lt;d&lt;Inf) : 0.1622109 ±0%\n\nAgainst denominator:\n  Null, mu1-mu2 = 0 \n---\nBayes factor type: BFindepSample, JZS\n\nttestBF(formula =  weight ~ group, data = pg_small, nullInterval=c(0, Inf), rscale=\"wide\")\n\nBayes factor analysis\n--------------\n[1] Alt., r=1 0&lt;d&lt;Inf    : 3.22134   ±0%\n[2] Alt., r=1 !(0&lt;d&lt;Inf) : 0.1189759 ±0.02%\n\nAgainst denominator:\n  Null, mu1-mu2 = 0 \n---\nBayes factor type: BFindepSample, JZS\n\nttestBF(formula =  weight ~ group, data = pg_small, nullInterval=c(0, Inf), rscale=\"ultrawide\")\n\nBayes factor analysis\n--------------\n[1] Alt., r=1.414 0&lt;d&lt;Inf    : 2.857414   ±0%\n[2] Alt., r=1.414 !(0&lt;d&lt;Inf) : 0.08596477 ±0.05%\n\nAgainst denominator:\n  Null, mu1-mu2 = 0 \n---\nBayes factor type: BFindepSample, JZS\n\n\nIndeed we do get stronger odds for the alternative hypothesis in the medium scale than the others. Note that it isn’t wise to go Bayes Factor fishing by post-hoc selecting the prior in order to maximise the Bayes Factor. This example was an exercise to show that prior selection is important.\n\n\n\n\n\n\nRoundup\n\n\n\n\nBayes Factor \\(t\\)-tests allow us to directly compare hypothesis about data in a way that is analogous to \\(t\\)-tests.\nWe can compare different hypotheses\nThe interpretation of a BayesFactor tells us which of the hypotheses are favoured by the data\nPrior selection is important, but ttestBF() restricts us to sensible options for data we assume to be normal",
    "crumbs": [
      "Tests with Bayes Factors",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Bayes Factor $t$-tests</span>"
    ]
  },
  {
    "objectID": "bayes_anova.html",
    "href": "bayes_anova.html",
    "title": "3  Bayes Factor ANOVA",
    "section": "",
    "text": "3.1 About this chapter",
    "crumbs": [
      "Tests with Bayes Factors",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Bayes Factor ANOVA</span>"
    ]
  },
  {
    "objectID": "bayes_anova.html#about-this-chapter",
    "href": "bayes_anova.html#about-this-chapter",
    "title": "3  Bayes Factor ANOVA",
    "section": "",
    "text": "Questions\n\nHow can I do an ANOVA?\n\nObjectives\n\nUnderstand multiplicity is not a problem for Bayes Factors\n\nKeypoints\n\nThe package simplebf automates Bayes Factor \\(t\\)-tests for many samples",
    "crumbs": [
      "Tests with Bayes Factors",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Bayes Factor ANOVA</span>"
    ]
  },
  {
    "objectID": "bayes_anova.html#the-issue-of-multiplicity-in-frequentism-and-bayesianism",
    "href": "bayes_anova.html#the-issue-of-multiplicity-in-frequentism-and-bayesianism",
    "title": "3  Bayes Factor ANOVA",
    "section": "3.2 The issue of multiplicity in Frequentism and Bayesianism",
    "text": "3.2 The issue of multiplicity in Frequentism and Bayesianism\nThe ANOVA is often seen to be a catch-all test that can be used for an experiment that has more than two samples in it. Experimenters often understand this to be true on the basis that ‘you shouldn’t do \\(t\\)-tests for more than two samples by repeating the \\(t\\)-test’. This is quite true and is a strategy for avoidance of the problem of multiplicity.\nMultiplicity or multiple testing occurs when we do lots of tests one after the other, in a batch. The more we do, the more likely we are to make an error in our conclusions (not in our working). This happens in Frequentist statistical tests because the \\(p\\)-value expresses a fixed error rate that we are happy to accept.\nRecall that the \\(t\\)-test has two hypotheses (of which we test just one)\n\\(H_0 : \\bar{x_1} - \\bar{x_2} = 0\\)\n\\(H_1 : \\bar{x_1} - \\bar{x_2} \\neq 0\\)\nand we set a level at which would reject \\(H_0\\) usually \\(p &lt; 0.05\\). The \\(p\\) reflects the proportion of times that the difference observed is seen in the null model by chance (so we see the difference 1 in 20 times by chance), in other words in a proportion of 0.95 of times we would reject the null correctly. Which is fine for just one comparison.\nIf we do more than one test we must multiply these probabilities together, giving \\(0.95 * 0.95 = 0.9025\\). This is catastrophic, by doing just two tests we reduce the proportion of times we choose the correct hypothesis to 0.9025, down from 19/20 to 18/20, we make twice as many mistakes! For more tests this gets worse.\nFrequentist statistics have lots of corrections for this sort of problem and the ANOVA post-hoc tests are in part a way of doing that. The good news for those using Bayes Factors is that this problem does not exist. Because we don’t have a fixed error rate, it doesn’t get bigger when we do more tests. We are free to do as many hypothesis comparisons as we wish.",
    "crumbs": [
      "Tests with Bayes Factors",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Bayes Factor ANOVA</span>"
    ]
  },
  {
    "objectID": "bayes_anova.html#automating-bayesfactorttest-for-many-comparisions",
    "href": "bayes_anova.html#automating-bayesfactorttest-for-many-comparisions",
    "title": "3  Bayes Factor ANOVA",
    "section": "3.3 Automating BayesFactor::ttest() for many comparisions",
    "text": "3.3 Automating BayesFactor::ttest() for many comparisions\nAs there isn’t a need for a Bayes Factor analogue to the ANOVA and post-hoc tests, we can just use the \\(t\\)-test analogue over and over again. If we have a multiple sample dataset we just need a book-keeping method to pull out the samples of interest.\nLet’s draft one with dplyr and the Plant Growth data set.\n\nlibrary(dplyr)\nlibrary(BayesFactor)\n\nsmall_df &lt;- PlantGrowth %&gt;% \n    filter(group %in% c(\"ctrl\", \"trt1\")) %&gt;% \n    droplevels()\n  \nttestBF(formula = weight ~ group, data = small_df)\n\nThis pattern helps you extract the pairs of samples you need, though you would need to repeat it every time you wanted to analyse a new pair. A convenience function for the simple case that allows us to do BayesFactor::ttestBF() for all pairs in a specified column in a dataframe exists in the package simplebf. It works like this:\n\nlibrary(simplebf)\nresult &lt;- allpairs_ttestbf(PlantGrowth, \n                           group_col = \"group\", data_col = \"weight\", \n                           rscale = \"medium\", \n                           h_1 = \"test_greater_than_control\")\n\nknitr::kable(result, digits = 4)\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontrol_group\ntest_group\nh_0\nh_1\nBayesFactor\nodds_h_1\nsummary\n\n\n\n\ntrt1\nctrl\nctrl equal to trt1\nctrl greater than trt1\n1.0834\n1:1.0834\nAnecdotal evidence for H_1 compared to H_0\n\n\ntrt2\nctrl\nctrl equal to trt2\nctrl greater than trt2\n0.1622\n1:0.1622\nSubstantial evidence for H_0 compared to H_1\n\n\nctrl\ntrt1\ntrt1 equal to ctrl\ntrt1 greater than ctrl\n0.2167\n1:0.2167\nSubstantial evidence for H_0 compared to H_1\n\n\ntrt2\ntrt1\ntrt1 equal to trt2\ntrt1 greater than trt2\n0.1363\n1:0.1363\nSubstantial evidence for H_0 compared to H_1\n\n\nctrl\ntrt2\ntrt2 equal to ctrl\ntrt2 greater than ctrl\n3.3872\n1:3.3872\nSubstantial evidence for H_1 compared to H_0\n\n\ntrt1\ntrt2\ntrt2 equal to trt1\ntrt2 greater than trt1\n12.6445\n1:12.6445\nStrong evidence for H_1 compared to H_0\n\n\n\n\n\nThe results are pretty easy to read. Note we can set rscale values as in the ttestBF() and we can choose one of three values for \\(H_1\\) test_greater_than_control, test_less_than_control and test_not_equal_to_control.\n\n\n\n\n\n\nRoundup\n\n\n\n\nBayes Factors do not need multiple hypothesis corrections\nsimplebf is a package for automating the comparison of all groups in a single variable in a tidy dataframe",
    "crumbs": [
      "Tests with Bayes Factors",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Bayes Factor ANOVA</span>"
    ]
  },
  {
    "objectID": "bayes_proportion.html",
    "href": "bayes_proportion.html",
    "title": "4  Bayes Factor on Contingency Tables and Proportions",
    "section": "",
    "text": "4.1 About this chapter\nThe BayesFactor package has some functions for performing other types of tests and returning a Bayes Factor. In this section we will briefly look at these.",
    "crumbs": [
      "Tests with Bayes Factors",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Bayes Factor on Contingency Tables and Proportions</span>"
    ]
  },
  {
    "objectID": "bayes_proportion.html#about-this-chapter",
    "href": "bayes_proportion.html#about-this-chapter",
    "title": "4  Bayes Factor on Contingency Tables and Proportions",
    "section": "",
    "text": "Questions\n\nHow can I do a categoric count based \\(\\chi^2\\) or proportional test with Bayes Factors?\n\nObjectives\n\nPerform \\(\\chi^2\\) on contingency tables of any size\n\nKeypoints\n\nBayesFactor and simplebf provide functions and automations for categorical count or frequency data\nThese are useful for HR scoring data",
    "crumbs": [
      "Tests with Bayes Factors",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Bayes Factor on Contingency Tables and Proportions</span>"
    ]
  },
  {
    "objectID": "bayes_proportion.html#bayes-factor-chi2",
    "href": "bayes_proportion.html#bayes-factor-chi2",
    "title": "4  Bayes Factor on Contingency Tables and Proportions",
    "section": "4.2 Bayes Factor \\(\\chi^2\\)",
    "text": "4.2 Bayes Factor \\(\\chi^2\\)\nA common question is whether proportions of counted things or frequency is different between samples. The one we typically learn first as biologists is Mendel’s pea data that led to his genetic insights, like this 2x2 table for flower colour (purple or white). Note that we have the counts of flower colour that were observed and expected counts that would come from a 3:1 Mendelian segregating cross.\n\nmendel_data\n\n           P   W\nobserved 459 141\nexpected 450 150\n\n\nThe \\(\\chi^2\\) test is the classical frequentist test performed to determine differences in proportions in a contingency table, and there is an equivalent Bayesian method in BayesFactor. We can run our data through the function contingencyTableBF() very easily, but it does need the data to be an R matrix object, not the more typical dataframe. We can change that easily with as.matrix(), then run the function.\nThe arguments are important: fixedMargin describes whether the variable of interest is in the rows or columns of the table - here it is in the columns so we use cols; sampleType describes what the function should do in the Bayesian sampling process as it runs. This is highly technical and out of scope for what we want to discuss, so I’m going to gloss over it. The function documentation has more information if you want it (?contingencyTableBF) the option used here indepMulti is a good one to start with.\n\nmendel_matrix &lt;- as.matrix(mendel_data)\n\nlibrary(BayesFactor)\ncontingencyTableBF(mendel_matrix, sampleType = \"indepMulti\", fixedMargin='cols')\n\nBayes factor analysis\n--------------\n[1] Non-indep. (a=1) : 0.1011097 ±0%\n\nAgainst denominator:\n  Null, independence, a = 1 \n---\nBayes factor type: BFcontingencyTable, independent multinomial\n\n\nThe hypotheses that are tested in this example are fixed and simple ones. Strictly \\(H_0\\) is that the proportions in the table are equal and \\(H_1\\) is that the proportions are not equal. So in effect the whole table is tested to see whether the observed counts are different to the expected counts. Here we see that the odds are 1:0.101 against \\(H_1\\) so the conclusion is that the proportions are equal, that is our observed flower colour proportions match the expected.\nThere isn’t a way to use different \\(H_1\\)’s in the way that we did with the Bayes Factor \\(t\\)-test, so we can’t test the explicit hypothesis that one is bigger (or smaller than the other).\n\n4.2.1 Converting a dataframe to a contingency table\nIn most of our work we’ve used tidy data (or case based data) in dataframes. The function we just learned uses a contingency table in a matrix, not a dataframe. Sometimes too, we will want to make a contingency table to see it. We can make a contingency table out of a dataframe with the table function, we just have to select the columns we want using the $ notation.\n\nhr_df\n\n# A tibble: 9 × 3\n  strain  replicate score\n  &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;\n1 control         1     1\n2 mild            1     3\n3 deadly          1     4\n4 control         2     2\n5 mild            2     3\n6 deadly          2     4\n7 control         3     1\n8 mild            3     3\n9 deadly          3     3\n\nhr_cont_table &lt;- table(hr_df$score,hr_df$strain) \n\n\n\n4.2.2 Bigger contingency tables\nSometime we’ll have a contingency table of counts that is larger than 2 x 2 IE we have more than two samples and more than two levels of a variable. For example we might have this HR scoring table.\n\nhr_table\n\n   \n    control deadly mild\n  1       2      0    0\n  2       1      0    0\n  3       0      1    3\n  4       0      2    0\n\n\nAs we can see it shows an HR score in the rows and different strains in the columns. The numbers represent the count of times each score was seen in three replicated experiments. Because it’s a contingency table the replicates are merged in together. It is important therefore that the same amount of sampling was done in each strain.\nHere we would want to compare the two basic hypotheses of whether the proportions of observed scores are different between the strains are the same or not. Let’s go ahead and do that with contingencyTableBF()\n\ncontingencyTableBF(hr_table, sampleType = \"indepMulti\", fixedMargin = \"cols\")\n\nBayes factor analysis\n--------------\n[1] Non-indep. (a=1) : 11.55 ±0%\n\nAgainst denominator:\n  Null, independence, a = 1 \n---\nBayes factor type: BFcontingencyTable, independent multinomial\n\n\nWe get a clear answer, the Bayes Factor strongly favours the hypothesis that the proportions of scores across strains are not equal. Which is nice but it doesn’t go far enough - it doesn’t tell us which are bigger than others and whether the conclusion applies to all the possible pairings of strains. This is the same problem we had with the Bayes Factor \\(t\\)-test and the solution is the same. We can just pull out each pair of strains and compare them one pair at a time. All we need is a book-keeping method to do this. The library simplebf contains one, so let’s use that.\nWe can use the allpairs_proportionbf() function to get a data frame of Bayes Factors. If you pass this function a dataframe it will make the contingency table for you. You must specify which columns to use for the group and the counts. For easy reading we’ll send the output to the knitr::kable() function.\n\nlibrary(simplebf)\nallpairs_proportionbf(hr_df, \n                        group_col = \"strain\", count_col = \"score\", \n                        sample_type = \"indepMulti\") %&gt;% \n  knitr::kable()\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontrol_group\ntest_group\nh_0\nh_1\nBayesFactor\nodds_h_1\nsummary\n\n\n\n\ncontrol\nmild\nmild proportions equal to control proportions\nmild proportions not equal to control proportions\n5.6000\n1:5.6\nSubstantial evidence for H_1 compared to H_0\n\n\ncontrol\ndeadly\ndeadly proportions equal to control proportions\ndeadly proportions not equal to control proportions\n4.2000\n1:4.2\nSubstantial evidence for H_1 compared to H_0\n\n\nmild\ndeadly\ndeadly proportions equal to mild proportions\ndeadly proportions not equal to mild proportions\n2.1875\n1:2.1875\nAnecdotal evidence for H_1 compared to H_0\n\n\n\n\n\nSo we get a nice set of Bayesian Hypothesis test for proportion or contingency table data on our HR experiment.\n\n\n\n\n\n\nRoundup\n\n\n\n\nBayes Factors can be used for proportion tests like the \\(\\chi^2\\)\nThe BayesFactor and simplebf packages are useful tools implementing these",
    "crumbs": [
      "Tests with Bayes Factors",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Bayes Factor on Contingency Tables and Proportions</span>"
    ]
  },
  {
    "objectID": "prerequisites.html",
    "href": "prerequisites.html",
    "title": "Prerequisites",
    "section": "",
    "text": "Knowledge prerequisites\nThere are no specific knowledge prerequisites for this book but it will be very helpful if you have read and worked through the ggplot, Intro to Stats and Estimation Statistics books and are familiar with R use.",
    "crumbs": [
      "Appendices",
      "Prerequisites"
    ]
  },
  {
    "objectID": "prerequisites.html#installing-r",
    "href": "prerequisites.html#installing-r",
    "title": "Prerequisites",
    "section": "Installing R",
    "text": "Installing R\nFollow this link and install the right version for your operating system https://www.stats.bris.ac.uk/R/",
    "crumbs": [
      "Appendices",
      "Prerequisites"
    ]
  },
  {
    "objectID": "prerequisites.html#installing-rstudio",
    "href": "prerequisites.html#installing-rstudio",
    "title": "Prerequisites",
    "section": "Installing RStudio",
    "text": "Installing RStudio\nFollow this link and install the right version for your operating system https://www.rstudio.com/products/rstudio/download/",
    "crumbs": [
      "Appendices",
      "Prerequisites"
    ]
  },
  {
    "objectID": "prerequisites.html#installing-r-packages-in-rstudio",
    "href": "prerequisites.html#installing-r-packages-in-rstudio",
    "title": "Prerequisites",
    "section": "Installing R packages in RStudio",
    "text": "Installing R packages in RStudio\n\nStandard packages\nIn the RStudio console, type\ninstall.packages(c(\"tidyverse\", \"devtools\", \"BayesFactor\"))\nand these packages should install. Once that is done, type\ndevtools::install_github(\"danmaclean/simplebf\")\nto install the final package",
    "crumbs": [
      "Appendices",
      "Prerequisites"
    ]
  },
  {
    "objectID": "r-fundamentals.html",
    "href": "r-fundamentals.html",
    "title": "R Fundamentals",
    "section": "",
    "text": "About this chapter",
    "crumbs": [
      "Appendices",
      "R Fundamentals"
    ]
  },
  {
    "objectID": "r-fundamentals.html#about-this-chapter",
    "href": "r-fundamentals.html#about-this-chapter",
    "title": "R Fundamentals",
    "section": "",
    "text": "Questions:\n\n\nHow do I use R?\n\n\nObjectives:\n\n\nBecome familiar with R syntax\nUnderstand the concepts of objects and assignment\nGet exposed to a few functions\n\n\nKeypoints:\n\n\nR’s capabilities are provided by functions\nR users call functions and get results",
    "crumbs": [
      "Appendices",
      "R Fundamentals"
    ]
  },
  {
    "objectID": "r-fundamentals.html#working-with-r",
    "href": "r-fundamentals.html#working-with-r",
    "title": "R Fundamentals",
    "section": "Working with R",
    "text": "Working with R\nIn this workshop we’ll use R in the extremely useful RStudio software. For the most part we’ll work interactively, meaning we’ll type stuff straight into the R console in RStudio (Usually this is a window on the left or lower left) and get our results there too (usually in the console or in a window on the right).\nPanels like the ones below mimic the interaction with R and first show the thing to type into R, and below the calculated result from R.\nLet’s look at how R works by using it for it’s most basic job - as a calculator:\n\n 3 + 5\n\n[1] 8\n\n\n\n 12 * 2\n\n[1] 24\n\n\n\n 1 / 3\n\n[1] 0.3333333\n\n\n\n 12 * 2\n\n[1] 24\n\n\nFairly straightforward, we type in the expression and we get a result. That’s how this whole book will work, you type the stuff in, and get answers out. It’ll be easiest to learn if you go ahead and copy the examples one by one. Try to resist the urge to use copy and paste. Typing longhand really encourages you to look at what you’re entering.\nAs far as the R output itself goes, it’s really straightforward - its just the answer with a [1] stuck on the front. This [1] tells us how many items through the output we are. Often R will return long lists of numbers and it can be helpful to have this extra information.",
    "crumbs": [
      "Appendices",
      "R Fundamentals"
    ]
  },
  {
    "objectID": "r-fundamentals.html#variables",
    "href": "r-fundamentals.html#variables",
    "title": "R Fundamentals",
    "section": "Variables",
    "text": "Variables\nWe can save the output of operations for later use by giving it a name using the assignment symbol &lt;-. Read this symbol as ‘gets’, so x &lt;- 5 reads as ‘x gets 5’. These names are called variables, because the value they are associated with can change.\nLet’s give five a name, x then refer to the value 5 by it’s name. We can then use the name in place of the value. In the jargon of computing we say we are assigning a value to a variable.\n\n x &lt;- 5\n x\n\n[1] 5\n\n\n\n x * 2\n\n[1] 10\n\n\n\ny &lt;- 3\nx * y\n\n[1] 15\n\n\nThis is of course of limited value with just numbers but is of great value when we have large datasets, as the whole thing can be referred to by the variable.\n\nUsing objects and functions\nAt the top level, R is a simple language with two types of thing: functions and objects. As a user you will use functions to do stuff, and get back objects as an answer. Functions are easy to spot, they are a name followed by a pair of brackets. A function like mean() is the function for calculating a mean. The options (or arguments) for the function go inside the brackets:\n\nsqrt(16)\n\n[1] 4\n\n\nOften the result from a function will be more complicated than a simple number object, often it will be a vector (simple list), like from the rnorm() function that returns lists of random numbers\n\nrnorm(100)\n\n  [1] -0.02476748 -2.09136358 -1.02248934 -1.69744992  0.05895667  1.05503207\n  [7] -0.40040538 -0.41351914  0.83916774  0.89212636  0.82207807 -0.20276934\n [13]  2.11878807 -0.42455996 -0.18392086  0.27170223 -2.16481407 -0.27348207\n [19]  0.06313183 -1.15107523  0.66228362 -1.57499961 -0.34725496 -0.66656242\n [25]  0.14280066 -0.79012779  0.35711738  0.39136287 -0.29582966  0.52169592\n [31] -2.13648457 -0.98489764  0.20165470 -0.46222511  1.76613291  0.23566183\n [37] -0.95943435  0.45944775 -0.66857532 -0.77478307  1.67368231  1.71417594\n [43]  1.97003539 -0.95841292 -2.00321029 -0.04826576  0.68218269 -1.15167289\n [49] -0.66635554  1.35439502  0.45565879 -0.62651434  0.69841996 -0.40658964\n [55]  0.44409602  0.76678923 -0.78978946 -0.51999011  0.42588982  0.06446149\n [61] -0.62013442  0.44559813  0.05614267 -0.68609116 -0.75702382  0.71240167\n [67]  0.06199338 -1.33377884 -1.35234383 -0.82703642 -0.30709308 -0.34152447\n [73]  0.92198832  2.24893939  0.77732355 -1.42433973 -1.38758750  0.07225661\n [79] -0.69868325  2.22281381  0.22834503 -0.72941394  1.05884078  1.04236582\n [85]  0.50427947 -0.59658971 -0.96539837  0.95475318  0.87568177  0.44492787\n [91] -1.51892945 -0.70582627  0.10080041 -0.98445775 -0.37962687 -1.17928429\n [97] -0.03900438  0.87483167  0.65202058  0.55416549\n\n\nWe can combine objects, variables and functions to do more complex stuff in R, here’s how we get the mean of 100 random numbers.\n\nnumbers &lt;- rnorm(100)\nmean(numbers)\n\n[1] 0.06075975\n\n\nHere we created a vector object with rnorm(100) and assigned it to the variable numbers. We than used the mean() function, passing it the variable numbers. The mean() function returned the mean of the hundred random numbers.",
    "crumbs": [
      "Appendices",
      "R Fundamentals"
    ]
  },
  {
    "objectID": "r-fundamentals.html#dataframes",
    "href": "r-fundamentals.html#dataframes",
    "title": "R Fundamentals",
    "section": "Dataframes",
    "text": "Dataframes\nOne of the more common objects that R uses is a dataframe. The dataframe is a rectangular table-like object that contains data, think of it like a spreadsheet tab. Like the spreadsheet, the dataframe has rows and columns, the columns have names and the different columns can have different types of data in. Here’s a little one\n\n\n  names age     score\n1 Guido  24 56.079663\n2 Marty  45 56.485117\n3  Alan  11  5.013943\n\n\nUsually we get a dataframe by loading in data from an external source or as a result from functions, occasionally we’ll want to hand make one, which can be done with various functions, data.frame being the most common.\n\ndata.frame(\n  names = c(\"Guido\", \"Marty\", \"Alan\"),\n  age = c(24,45,11),\n  score = runif(3) * 100\n)",
    "crumbs": [
      "Appendices",
      "R Fundamentals"
    ]
  },
  {
    "objectID": "r-fundamentals.html#packages",
    "href": "r-fundamentals.html#packages",
    "title": "R Fundamentals",
    "section": "Packages",
    "text": "Packages\nMany of the tools we use in will come in R packages, little nuggets of code that group related functions together. Installing new packages can be done using the Packages pane of RStudio or the install.packages() function. When we wish to use that code we use the library() function\n\nlibrary(somepackage)",
    "crumbs": [
      "Appendices",
      "R Fundamentals"
    ]
  },
  {
    "objectID": "r-fundamentals.html#using-r-help",
    "href": "r-fundamentals.html#using-r-help",
    "title": "R Fundamentals",
    "section": "Using R Help",
    "text": "Using R Help\nR provides a command, called ? that will display the documentation for functions. For example ?mean will display the help for the mean() function.\n\n?mean\n\nAs in all programming languages the internal documentation in R is written with some assumption that the reader is familiar with the language. This can be a pain when you are starting out as the help will seem a bit obscure at times. Don’t worry about this, usually the Examples section will give you a good idea of how to use the function and as your experience grows then the more things will make more sense.\n\n\n\n\n\n\nRoundup\n\n\n\n* R is an excellent and powerful statistical computing environment\n\n\n\n\n\n\n\n\nFor you to do\n\n\n\nComplete the interactive tutorial online https://danmaclean.shinyapps.io/r-start",
    "crumbs": [
      "Appendices",
      "R Fundamentals"
    ]
  }
]